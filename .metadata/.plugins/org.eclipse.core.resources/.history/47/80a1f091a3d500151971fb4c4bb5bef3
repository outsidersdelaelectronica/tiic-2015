/*
 * main.c
 *
 *  Created on: 29/9/2015
 *      Author: Smau
 */

#include <msp430.h>

#include "clocks.h"

#include "afe/afe.h"
#include "buzzer/buzzer.h"
#include "display/display.h"
#include "display/display_src/display_functions.h"
#include "touch/touch.h"
#include "filters/filters.h"

#define BUFFER_SIZE 5
//buzzer_t buzzer;

display_t display;
//touch_t touch;
ecg_data_t last_sample,sample_buffer[BUFFER_SIZE];
int bpm,index;

int main()
{
	int i = 0, sample_value = 0,current_value = 0;
	uint16_t gie;

    WDTCTL = WDTPW | WDTHOLD;		//Stop watchdog timer
    bpm = 0;
    index = -1;
    ecg_data_clear(&last_sample);

    for(i = 0; i < BUFFER_SIZE; i++)
    {
    	ecg_data_clear(&sample_buffer[i]);
    }
    /*
     * Setups
     */
    clocks_setup();

    afe_setup();
    display_setup(&display);
//    touch_setup(&touch);
//    buzzer_setup(&buzzer);

    /*
     * MCU setup
     */

    PM5CTL0 &= ~LOCKLPM5;			//Disable the GPIO power-on default high-impedance mode

    /*
     * Initializations
     */
    afe_init();
    display_init(&display);
//    touch_initialize(&touch);

    /*
     * Sheits
     */

    display_functions_write_string(" BPM:           ", COLOR_RED,
	  	  	  	   	   	   	   	   	   	   	   	   	   	   display.display_interface.menubar_window_bg_color,
														   0x00, 0xC0);
    display_functions_write_string(" DANGER: Apechusque ", COLOR_WHITE,
														   display.display_interface.menubar_window_bg_color,
														   0x00, 0xD0);

	__bis_SR_register(GIE);			//Enable global interrupts

	while(1)
	{
		if (index >= 0)
		{
//			ecg_data_copy(&sample_buffer[index],&last_sample);
			sample_value = sample_buffer[0].data;

			__disable_interrupt();                    //Make this operation atomic

			for (i = 0; i < index; i++)
			{
				ecg_data_copy(&sample_buffer[i+1],&sample_buffer[i]);
			}
			index--;

			__enable_interrupt();                    //Restore original GIE state

			current_value = filter_sample(sample_value);

			last_sample.data = current_value;

//			if(current_value >= ((threshold * 7) >>3) )
//			{
//				if (current_value >= maxerino )
//				{
//					maxerino = current_value;
//					maxerino_pos = sample_counter;
//				}else if (flag == 0){
//					threshold = ((maxerino * 7) >>3);
//					flag = 1;
//				}
//			}else if ((prev_value >= ((threshold * 7) >> 3) ) && (maxerino > 0))
//			{
//				bpm =  (60 * FS) / maxerino_pos;
//				threshold = ((threshold * 7 + maxerino) >> 3);
//				sample_counter = sample_counter - maxerino_pos -1;
//				maxerino = 0;
//			}else{
//				threshold = ((threshold * 127) >> 7);
//				maxerino = 0;
//			}
//
//			sample_counter++;
//			prev_value = current_value;
		}
	}
}
